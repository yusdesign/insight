import { ASCIIVisualizer } from './ASCIIVisualizer.js';
import { MermaidVisualizer } from './MermaidVisualizer.js';

export class MarkdownReportGenerator {
    static generate(analysis, title = 'Architecture Analysis') {
        const { classes, relationships, insights } = analysis;
        const ascii = ASCIIVisualizer.render(analysis);
        const mermaid = MermaidVisualizer.generate(analysis);
        
        let markdown = `# 🏗️ ${title}\n\n`;
        markdown += `*Generated by Insight Suite JS2UML on ${new Date().toLocaleDateString()}*\n\n`;
        
        // Quick Stats
        markdown += `## 📊 Quick Stats\n\n`;
        markdown += `- **Classes**: ${insights.totalClasses}\n`;
        markdown += `- **Methods**: ${insights.totalMethods}\n`;
        markdown += `- **Quality Score**: ${insights.qualityScore}%\n`;
        markdown += `- **Relationships**: ${relationships.length}\n\n`;
        
        // Mermaid Diagram
        markdown += `## 📐 Architecture Diagram\n\n`;
        markdown += `${mermaid}\n\n`;
        
        // Classes Details
        markdown += `## 🏛️ Classes Details\n\n`;
        classes.forEach(cls => {
            const methodCount = cls.methods.declared.length;
            const propertyCount = cls.properties.length;
            const externalCount = cls.methods.external.length;
            
            markdown += `### ${cls.name}\n\n`;
            markdown += `**Methods (${methodCount}):**\n`;
            cls.methods.declared.forEach(method => {
                const icon = method === 'constructor' ? ' 🏗️' : '';
                markdown += `- \`${method}()\`${icon}\n`;
            });
            
            if (propertyCount > 0) {
                markdown += `\n**Properties (${propertyCount}):**\n`;
                cls.properties.forEach(prop => {
                    markdown += `- \`${prop}\`\n`;
                });
            }
            
            if (externalCount > 0) {
                markdown += `\n**External Dependencies (${externalCount}):**\n`;
                cls.methods.external.slice(0, 5).forEach(ext => {
                    markdown += `- \`${ext}\`\n`;
                });
                if (externalCount > 5) {
                    markdown += `- *... and ${externalCount - 5} more*\n`;
                }
            }
            markdown += '\n';
        });
        
        // ASCII Version (collapsible in GitHub)
        markdown += `<details>\n<summary>📋 ASCII Version</summary>\n\n`;
        markdown += '```ascii\n';
        markdown += ascii;
        markdown += '\n```\n\n';
        markdown += `</details>\n\n`;
        
        // Quality Assessment
        markdown += `## 🎯 Quality Assessment\n\n`;
        if (insights.qualityScore >= 80) {
            markdown += `🟢 **Excellent** - Well-structured architecture with clean separation of concerns.\n`;
        } else if (insights.qualityScore >= 60) {
            markdown += `🟡 **Good** - Solid foundation with some areas for improvement.\n`;
        } else {
            markdown += `🔴 **Needs Improvement** - Consider refactoring to improve architecture.\n`;
        }
        
        return markdown;
    }
}
